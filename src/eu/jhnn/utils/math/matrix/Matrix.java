package eu.jhnn.utils.math.matrix;

import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.function.Supplier;

import eu.jhnn.utils.math.functions.suppliers.NullSupplier;

public class Matrix<T> implements Iterable<T> {

	private final static int DEFAULT_SIZE = 3;

	private int columns, rows, numElements;
	private T[] mEntries;

	public Matrix() {
		this(DEFAULT_SIZE, DEFAULT_SIZE);
	}

	public Matrix(int columns, int rows) {
		this(columns, rows, new NullSupplier<T>());
	}

	public Matrix(int columns, int rows, Supplier<T> t) {
		setSize(rows, columns, t);
	}

	public int getColumnCount() {
		return columns;
	}

	public int getRowCount() {
		return rows;
	}

	public int getSize() {
		return mEntries.length;
	}

	public void setSize(int newRows, int newColumns, Supplier<T> empty) {
		@SuppressWarnings("unchecked")
		T[] newEntries = (T[]) new Object[newColumns * newRows];

		int c1 = Math.min(columns, newColumns);
		int c2 = Math.min(rows, newRows);

		int i = 0;

		while (i < c1) {
			// Copy old values
			int j = 0;
			while (j < c2) {
				newEntries[i * newRows + j] = mEntries[i * rows + j];

				j++;
			}

			// Fill empty rows
			while (j < newRows) {
				newEntries[i * newRows + j] = empty.get();

				j++;
			}

			i++;
		}

		// Fill remaining columns
		while (i < newColumns) {
			int j = 0;

			while (j < newRows) {
				newEntries[i * newRows + j] = empty.get();

				j++;
			}

			i++;
		}

		columns = newColumns;
		rows = newRows;
		numElements = columns * rows;

		mEntries = newEntries;
	}

	public void setSize(int newColumns, int newRows) {
		setSize(newRows, newColumns, new NullSupplier<>());
	}

	/**
	 * Sets all entries of this matrix to the given value. Note that all the entry
	 * will reference the same given instance.
	 * 
	 * @param value
	 */
	public void fill(T value) {
		for (int i = 0; i < mEntries.length; i++) {
			mEntries[i] = value;
		}
	}

	/**
	 * Sets all entries of this matrix to the new values generated by the factory.
	 * Note that each entry will reference to a different instance.
	 * 
	 * @param factory
	 */
	public void fill(Supplier<T> factory) {
		for (int i = 0; i < mEntries.length; i++) {
			mEntries[i] = factory.get();
		}
	}

	public T getElement(MatrixIndices indices) {
		return getElement(indices.row, indices.col);
	}

	public T getElement(int row, int column) {
		rangeCheck(row, column);

		return mEntries[column * rows + row];
	}

	public void setElement(int row, int column, T element) {
		rangeCheck(row, column);

		mEntries[column * rows + row] = element;
	}

	public boolean containsElementAtIndices(MatrixIndices indices) {
		return containsElementAtIndices(indices.row, indices.col);
	}

	public boolean containsElementAtIndices(int row, int column) {
		return !_rangeCheck(row, column);
	}

	/**
	 * @param row
	 * @param column
	 * @return true if row or column outside of range.
	 */
	private boolean _rangeCheck(int row, int column) {
		return row < 0 || column < 0 || column >= columns || row >= rows;
	}

	private void rangeCheck(int row, int column) {
		if (_rangeCheck(row, column)) {
			String error = String.format("Index (%d, %d), Size (%d, %d)", row, column, rows, columns);
			throw new IndexOutOfBoundsException(error);
		}
	}

	@Override
	public Iterator<T> iterator() {
		return new Itr();
	}

	private class Itr implements Iterator<T> {

		int cursor; // index of next element to return

		int lastRet = -1; // index of last element returned; -1 if no such

		public boolean hasNext() {
			return cursor < numElements;
		}

		public T next() {
			int i = cursor;

			if (i >= numElements)
				throw new NoSuchElementException();

			if (i >= mEntries.length)
				throw new ConcurrentModificationException();

			cursor = i + 1;

			return mEntries[lastRet = i];
		}

		public void remove() {

			if (lastRet < 0) {
				throw new IllegalStateException();
			}

			try {
				mEntries[lastRet] = null;
				cursor++;

				lastRet = -1;
			} catch (IndexOutOfBoundsException ex) {
				throw new ConcurrentModificationException();
			}
		}
	}
}
